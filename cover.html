
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>gophermart: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/plasmatrip/gratify/cmd/gophermart/main.go (0.0%)</option>
				
				<option value="file1">github.com/plasmatrip/gratify/internal/api/auth/auth.go (0.0%)</option>
				
				<option value="file2">github.com/plasmatrip/gratify/internal/api/auth/login.go (0.0%)</option>
				
				<option value="file3">github.com/plasmatrip/gratify/internal/api/auth/register.go (0.0%)</option>
				
				<option value="file4">github.com/plasmatrip/gratify/internal/api/auth/validate.go (0.0%)</option>
				
				<option value="file5">github.com/plasmatrip/gratify/internal/api/balance/balance.go (0.0%)</option>
				
				<option value="file6">github.com/plasmatrip/gratify/internal/api/balance/get_balance.go (0.0%)</option>
				
				<option value="file7">github.com/plasmatrip/gratify/internal/api/balance/withdraw.go (0.0%)</option>
				
				<option value="file8">github.com/plasmatrip/gratify/internal/api/balance/withdrawals.go (0.0%)</option>
				
				<option value="file9">github.com/plasmatrip/gratify/internal/api/info/info.go (0.0%)</option>
				
				<option value="file10">github.com/plasmatrip/gratify/internal/api/info/ping.go (0.0%)</option>
				
				<option value="file11">github.com/plasmatrip/gratify/internal/api/orders/add_order.go (0.0%)</option>
				
				<option value="file12">github.com/plasmatrip/gratify/internal/api/orders/get_orders.go (0.0%)</option>
				
				<option value="file13">github.com/plasmatrip/gratify/internal/api/orders/orders.go (0.0%)</option>
				
				<option value="file14">github.com/plasmatrip/gratify/internal/config/config.go (0.0%)</option>
				
				<option value="file15">github.com/plasmatrip/gratify/internal/logger/logger.go (0.0%)</option>
				
				<option value="file16">github.com/plasmatrip/gratify/internal/models/order.go (0.0%)</option>
				
				<option value="file17">github.com/plasmatrip/gratify/internal/repository/repository.go (0.0%)</option>
				
				<option value="file18">github.com/plasmatrip/gratify/internal/router/router.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "net/http"
        "os"
        "os/signal"

        "github.com/plasmatrip/gratify/internal/api"
        "github.com/plasmatrip/gratify/internal/config"
        "github.com/plasmatrip/gratify/internal/logger"
        "github.com/plasmatrip/gratify/internal/repository"
        "github.com/plasmatrip/gratify/internal/router"
)

func main() <span class="cov0" title="0">{
        ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt)
        defer stop()

        c, err := config.NewConfig()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">l, err := logger.NewLogger()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">defer l.Close()

        db, err := repository.NewRepository(ctx, c.Database, *l)
        if err != nil </span><span class="cov0" title="0">{
                l.Sugar.Infow("database connection error: ", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer db.Close()

        deps := &amp;api.Dependencies{
                Config: *c,
                Logger: *l,
                Repo:   *db,
        }

        server := http.Server{
                Addr: c.Host,
                Handler: func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                        l.Sugar.Infow("The loyalty system \"Gophermart\" server is running. ", "Server address: ", c.Host)
                        l.Sugar.Infow("Server config", "DATABASE_URI", c.Database, "ACCRUAL_SYSTEM_ADDRESS", c.Accrual)
                        return next
                }</span>(router.NewRouter(*deps)),
        }

        <span class="cov0" title="0">go server.ListenAndServe()

        &lt;-ctx.Done()

        server.Shutdown(context.Background())

        l.Sugar.Infow("The server has been shut down gracefully")

        os.Exit(0)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package auth

import (
        "time"

        "github.com/golang-jwt/jwt"
        "github.com/plasmatrip/gratify/internal/api"
        "github.com/plasmatrip/gratify/internal/models"
)

type ValidLogin struct {
}

type Claims struct {
        jwt.StandardClaims
        UserdID int32
}

type Auth struct {
        deps api.Dependencies
}

func NewAuthService(desp api.Dependencies) *Auth <span class="cov0" title="0">{
        return &amp;Auth{
                deps: desp,
        }
}</span>

func (a *Auth) LoginToken(lr models.LoginRequest) (string, error) <span class="cov0" title="0">{
        claims := Claims{
                StandardClaims: jwt.StandardClaims{
                        ExpiresAt: time.Now().Add(time.Hour * 72).Unix(),
                        Subject:   lr.Login,
                },
                UserdID: lr.ID,
        }
        // claims := jwt.MapClaims{
        //         "sub": lr.Login,
        //         "exp": time.Now().Add(time.Hour * 72).Unix(),
        // }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

        t, err := token.SignedString([]byte(a.deps.Config.TokenSecret))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return t, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package auth

import (
        "encoding/json"
        "errors"
        "net/http"

        "github.com/plasmatrip/gratify/internal/apperr"
        "github.com/plasmatrip/gratify/internal/models"
)

func (a *Auth) Login(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var lr models.LoginRequest

        if err := json.NewDecoder(r.Body).Decode(&amp;lr); err != nil </span><span class="cov0" title="0">{
                a.deps.Logger.Sugar.Infow("error in request handler", "error: ", err)
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if len(lr.Login) == 0 || len(lr.Password) == 0 </span><span class="cov0" title="0">{
                a.deps.Logger.Sugar.Infow("error in authentication data", "error: ", errors.New("empty login or password"))
                http.Error(w, "empty login or password", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">if err := a.deps.Repo.CheckLogin(r.Context(), lr); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, apperr.ErrBadLogin) </span><span class="cov0" title="0">{
                        a.deps.Logger.Sugar.Infow("authentication error", "error: ", err)
                        http.Error(w, "authentication error", http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov0" title="0">a.deps.Logger.Sugar.Infow("internal error", "error: ", err)
                http.Error(w, "internal server error", http.StatusInternalServerError)
                return</span>
        }

        <span class="cov0" title="0">token, err := a.LoginToken(lr)
        if err != nil </span><span class="cov0" title="0">{
                a.deps.Logger.Sugar.Infow("error generating JWT", "error: ", err)
                http.Error(w, "internal server error", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.Header().Set("Authorization", "Bearer "+token)
        w.WriteHeader(http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package auth

import (
        "encoding/json"
        "errors"
        "net/http"

        "github.com/jackc/pgx/v5/pgconn"
        "github.com/plasmatrip/gratify/internal/models"
        "github.com/rgurov/pgerrors"
)

func (a *Auth) Register(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var lr models.LoginRequest

        if err := json.NewDecoder(r.Body).Decode(&amp;lr); err != nil </span><span class="cov0" title="0">{
                a.deps.Logger.Sugar.Infow("error in request handler", "error: ", err)
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if len(lr.Login) == 0 || len(lr.Password) == 0 </span><span class="cov0" title="0">{
                a.deps.Logger.Sugar.Infow("error in authentication data", "error: ", errors.New("empty login or password"))
                http.Error(w, "empty login or password", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">id, err := a.deps.Repo.RegisterUser(r.Context(), lr)
        if err != nil </span><span class="cov0" title="0">{
                if pgErr, ok := err.(*pgconn.PgError); ok </span><span class="cov0" title="0">{
                        if pgErr.Code == pgerrors.UniqueViolation </span><span class="cov0" title="0">{
                                a.deps.Logger.Sugar.Infow("authentication error", "error: ", err)
                                http.Error(w, "authentication error", http.StatusConflict)
                                return
                        }</span>
                }

                <span class="cov0" title="0">a.deps.Logger.Sugar.Infow("internal error", "error: ", err)
                http.Error(w, "internal server error", http.StatusInternalServerError)
                return</span>
        }

        <span class="cov0" title="0">lr.ID = id

        token, err := a.LoginToken(lr)
        if err != nil </span><span class="cov0" title="0">{
                a.deps.Logger.Sugar.Infow("error generating JWT", "error: ", err)
                http.Error(w, "internal server error", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.Header().Set("Authorization", "Bearer "+token)
        w.WriteHeader(http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package auth

import (
        "context"
        "fmt"
        "net/http"
        "strings"

        "github.com/golang-jwt/jwt"
)

func (a Auth) Validate(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                authHeader := r.Header.Get("Authorization")
                if authHeader == "" </span><span class="cov0" title="0">{
                        a.deps.Logger.Sugar.Info("missing authorization header")
                        http.Error(w, "missing authorization header", http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov0" title="0">parts := strings.Split(authHeader, " ")
                if len(parts) != 2 || parts[0] != "Bearer" </span><span class="cov0" title="0">{
                        a.deps.Logger.Sugar.Infow("invalid authorization header format", "parts", parts)
                        http.Error(w, "invalid authorization header format", http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov0" title="0">tokenString := parts[1]

                claims := &amp;Claims{}

                token, err := jwt.ParseWithClaims(tokenString, claims,
                        func(t *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                                if _, ok := t.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("unexpected signing method: %v", t.Header["alg"])
                                }</span>
                                <span class="cov0" title="0">return []byte(a.deps.Config.TokenSecret), nil</span>
                        })

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        a.deps.Logger.Sugar.Infow("JWT token error", "error", err)
                        http.Error(w, "JWT token error", http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov0" title="0">if !token.Valid </span><span class="cov0" title="0">{
                        a.deps.Logger.Sugar.Infow("invalid token", "token", token)
                        http.Error(w, "invalid token", http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov0" title="0">ctx := context.WithValue(r.Context(), ValidLogin{}, claims)

                next.ServeHTTP(w, r.WithContext(ctx))</span>
        })
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package balance

import (
        "github.com/plasmatrip/gratify/internal/api"
)

type Balance struct {
        deps api.Dependencies
}

func NewBalanceService(deps api.Dependencies) *Balance <span class="cov0" title="0">{
        return &amp;Balance{
                deps: deps,
        }
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package balance

import "net/http"

func (b *Balance) GetBalance(w http.ResponseWriter, r *http.Request) {<span class="cov0" title="0">

}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package balance

import "net/http"

func (b *Balance) Withdraw(w http.ResponseWriter, r *http.Request) {<span class="cov0" title="0">

}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package balance

import "net/http"

func (b *Balance) Withdrawals(w http.ResponseWriter, r *http.Request) {<span class="cov0" title="0">

}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package info

import "github.com/plasmatrip/gratify/internal/api"

type Info struct {
        deps api.Dependencies
}

func NewInfoService(deps api.Dependencies) *Info <span class="cov0" title="0">{
        return &amp;Info{
                deps: deps,
        }
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package info

import (
        "net/http"
)

func (i *Info) Ping(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "text/html")

        err := i.deps.Repo.Ping(r.Context())
        if err != nil </span><span class="cov0" title="0">{
                i.deps.Logger.Sugar.Infow(err.Error())
                w.WriteHeader(http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package orders

import (
        "errors"
        "io"
        "net/http"
        "strconv"
        "strings"
        "time"

        "github.com/ShiraazMoollatjie/goluhn"
        "github.com/jackc/pgx/v5/pgconn"
        "github.com/plasmatrip/gratify/internal/api/auth"
        "github.com/plasmatrip/gratify/internal/apperr"
        "github.com/plasmatrip/gratify/internal/models"
        "github.com/rgurov/pgerrors"
)

func (o *Orders) AddOrder(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // var order = models.Order{}

        body, err := io.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                o.deps.Logger.Sugar.Infow("failed to read request body", "error: ", err)
                http.Error(w, "failed to read request body", http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">defer r.Body.Close()

        // Преобразуем тело запроса в строку и обрезаем лишние пробелы
        bodyStr := string(body)
        bodyStr = strings.TrimSpace(bodyStr)

        err = goluhn.Validate(bodyStr)
        if err != nil </span><span class="cov0" title="0">{
                o.deps.Logger.Sugar.Infow("Invalid order number format", "error: ", err)
                http.Error(w, "Invalid order number format", http.StatusUnprocessableEntity)
                return
        }</span>

        // Преобразуем строку в число
        <span class="cov0" title="0">orderID, err := strconv.ParseInt(bodyStr, 10, 64) // 64-битное целое число
        if err != nil </span><span class="cov0" title="0">{
                o.deps.Logger.Sugar.Infow("invalid order ID format", "error: ", err)
                http.Error(w, "invalid order ID format", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">userId := r.Context().Value(auth.ValidLogin{}).(*auth.Claims).UserdID

        order := models.Order{
                Number: orderID,
                UserID: userId,
                Status: models.StatusNew,
                Date:   time.Now(),
        }

        err = o.deps.Repo.AddOrder(r.Context(), order)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, apperr.ErrOrderAlreadyUploadedAnotherUser) </span><span class="cov0" title="0">{
                        o.deps.Logger.Sugar.Infow("error adding order", "error: ", err)
                        http.Error(w, "error adding order", http.StatusConflict)
                        return
                }</span>

                <span class="cov0" title="0">if pgErr, ok := err.(*pgconn.PgError); ok </span><span class="cov0" title="0">{
                        if pgErr.Code == pgerrors.UniqueViolation </span><span class="cov0" title="0">{
                                o.deps.Logger.Sugar.Infow("error adding order", "error: ", err)
                                http.Error(w, "error adding order", http.StatusOK)
                                return
                        }</span>

                        <span class="cov0" title="0">o.deps.Logger.Sugar.Infow("", "error: ", err)
                        http.Error(w, "", http.StatusBadRequest)
                        return</span>
                }

                <span class="cov0" title="0">o.deps.Logger.Sugar.Infow("error adding order", "error: ", err)
                http.Error(w, "error adding order", http.StatusInternalServerError)
                return</span>
        }

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusAccepted)</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package orders

import (
        "encoding/json"
        "net/http"
        "time"

        "github.com/plasmatrip/gratify/internal/api/auth"
        "github.com/plasmatrip/gratify/internal/models"
)

func (o *Orders) GetOrders(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userId := r.Context().Value(auth.ValidLogin{}).(*auth.Claims).UserdID

        orders, err := o.deps.Repo.GetOrders(r.Context(), userId)
        if err != nil </span><span class="cov0" title="0">{
                o.deps.Logger.Sugar.Infow("internal server error", "error: ", err)
                http.Error(w, "internal server error", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if len(orders) == 0 </span><span class="cov0" title="0">{
                o.deps.Logger.Sugar.Infow("no data", "error: ", err)
                http.Error(w, "no data", http.StatusNoContent)
                return
        }</span>

        <span class="cov0" title="0">prepareOrder := make([]models.ResponseOrder, len(orders))
        for i, order := range orders </span><span class="cov0" title="0">{
                prepareOrder[i] = models.ResponseOrder{
                        Number:  order.Number,
                        Status:  order.Status.String(),
                        Accrual: order.Accrual,
                        Date:    order.Date.Format(time.RFC3339),
                }
        }</span>

        <span class="cov0" title="0">foundOrders, err := json.Marshal(prepareOrder)
        if err != nil </span><span class="cov0" title="0">{
                o.deps.Logger.Sugar.Infow("serialization error", "error: ", err)
                http.Error(w, "internal server error", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        _, err = w.Write(foundOrders)
        if err != nil </span><span class="cov0" title="0">{
                o.deps.Logger.Sugar.Infow("data write error", "error: ", err)
                http.Error(w, "internal server error", http.StatusInternalServerError)
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package orders

import (
        "github.com/plasmatrip/gratify/internal/api"
)

type Orders struct {
        deps api.Dependencies
}

func NewOrdersService(deps api.Dependencies) *Orders <span class="cov0" title="0">{
        return &amp;Orders{
                deps: deps,
        }
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package config

import (
        "errors"
        "flag"
        "fmt"
        "os"
        "path/filepath"
        "strconv"
        "strings"

        "github.com/caarlos0/env"
        "github.com/joho/godotenv"
)

const (
        port     = "8080"
        host     = "localhost"
        accrual  = ""
        database = "postgres://gratify:password@localhost:5432/gratify?sslmode=disable"
)

type Config struct {
        Host        string `env:"RUN_ADDRESS"`
        Database    string `env:"DATABASE_URI"`
        Accrual     string `env:"ACCRUAL_SYSTEM_ADDRESS"`
        TokenSecret string `env:"TOKEN_SECRET"`
}

func NewConfig() (*Config, error) <span class="cov0" title="0">{
        cfg := &amp;Config{}

        ex, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := godotenv.Load(filepath.Dir(ex) + "/.env"); err != nil </span><span class="cov0" title="0">{
                return nil, errors.New(".env not found")
        }</span>

        <span class="cov0" title="0">cl := flag.NewFlagSet(os.Args[0], flag.ContinueOnError)

        // читаем переменные окружения, при ошибке прокидываем ее наверх
        if err := env.Parse(cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read environment variable: %w", err)
        }</span>

        <span class="cov0" title="0">var fHost string
        cl.StringVar(&amp;fHost, "a", host+":"+port, "server address host:port")

        var fDatabase string
        cl.StringVar(&amp;fDatabase, "d", database, "")

        var fAccrual string
        cl.StringVar(&amp;fAccrual, "r", accrual, "")

        if err := cl.Parse(os.Args[1:]); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse flags: %w", err)
        }</span>

        <span class="cov0" title="0">if _, exist := os.LookupEnv("RUN_ADDRESS"); !exist </span><span class="cov0" title="0">{
                cfg.Host = fHost
        }</span>

        <span class="cov0" title="0">if _, exist := os.LookupEnv("DATABASE_URI"); !exist </span><span class="cov0" title="0">{
                cfg.Database = fDatabase
        }</span>

        <span class="cov0" title="0">if _, exist := os.LookupEnv("ACCRUAL_SYSTEM_ADDRESS"); !exist </span><span class="cov0" title="0">{
                cfg.Accrual = fAccrual
        }</span>

        <span class="cov0" title="0">if err := parseAddress(cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("port parsing error: %w", err)
        }</span>

        <span class="cov0" title="0">return cfg, nil</span>
}

func parseAddress(cfg *Config) error <span class="cov0" title="0">{
        args := strings.Split(cfg.Host, ":")
        if len(args) == 2 </span><span class="cov0" title="0">{
                if len(args[0]) == 0 || len(args[1]) == 0 </span><span class="cov0" title="0">{
                        cfg.Host = host + ":" + port
                        return nil
                }</span>

                <span class="cov0" title="0">_, err := strconv.ParseInt(args[1], 10, 64)
                return err</span>
        }
        <span class="cov0" title="0">cfg.Host = host + ":" + port
        return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package logger

import (
        "net/http"
        "time"

        "go.uber.org/zap"
)

type (
        responseData struct {
                status int
                size   int
        }

        loggingResponseWriter struct {
                http.ResponseWriter
                responseData *responseData
        }

        Logger struct {
                zap   *zap.Logger
                Sugar *zap.SugaredLogger
        }
)

func (r *loggingResponseWriter) Write(b []byte) (int, error) <span class="cov0" title="0">{
        size, err := r.ResponseWriter.Write(b)
        r.responseData.size += size
        return size, err
}</span>

func (r *loggingResponseWriter) WriteHeader(status int) <span class="cov0" title="0">{
        r.ResponseWriter.WriteHeader(status)
        r.responseData.status = status
}</span>

func NewLogger() (*Logger, error) <span class="cov0" title="0">{
        zap, err := zap.NewDevelopment()
        return &amp;Logger{zap: zap, Sugar: zap.Sugar()}, err
}</span>

func (l *Logger) Close() <span class="cov0" title="0">{
        l.zap.Sync()
}</span>

func (l *Logger) WithLogging(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                start := time.Now()

                responseData := &amp;responseData{
                        status: 0,
                        size:   0,
                }
                lw := loggingResponseWriter{
                        ResponseWriter: w,
                        responseData:   responseData,
                }

                next.ServeHTTP(&amp;lw, r)

                duration := time.Since(start)

                var logMsg []interface{}

                switch r.Method </span>{
                case http.MethodGet:<span class="cov0" title="0">
                        logMsg = append(logMsg, "URI", r.RequestURI, "  METHOD:", r.Method, "  DURATION:", duration)</span>
                case http.MethodPost:<span class="cov0" title="0">
                        logMsg = append(logMsg, "URI", r.RequestURI, "  METHOD:", r.Method,
                                "  DURATION:", duration, "  STATUS", responseData.status, "  SIZE", responseData.size)</span>
                }

                <span class="cov0" title="0">l.Sugar.Infoln(logMsg...)</span>
        })
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package models

import (
        "database/sql/driver"
        "time"
)

type Status int

const (
        StatusNew Status = iota
        StatusRegistered
        StatusProcessing
        StatusProcessed
        StatusInvalid
        StatusUnknown
)

type Order struct {
        Number  int64     `json:"number"`
        UserID  int32     `json:"-"`
        Status  Status    `json:"status"`
        Accrual int       `json:"accrual,omitempty"`
        Sum     int       `json:"-"`
        Date    time.Time `json:"uploaded_at"`
}

type ResponseOrder struct {
        Number  int64  `json:"number"`
        Status  string `json:"status"`
        Accrual int    `json:"accrual,omitempty"`
        Date    string `json:"uploaded_at"`
}

// deserialize from DB
func (s *Status) Scan(value interface{}) error <span class="cov0" title="0">{
        *s = toStatus(value.(string))
        return nil
}</span>

// serialize to DB
func (s Status) Value() (driver.Value, error) <span class="cov0" title="0">{
        return s.String(), nil
}</span>

func toStatus(s string) Status <span class="cov0" title="0">{
        switch s </span>{
        case "NEW":<span class="cov0" title="0">
                return StatusNew</span>
        case "REGISTERED":<span class="cov0" title="0">
                return StatusRegistered</span>
        case "PROCESSING":<span class="cov0" title="0">
                return StatusProcessing</span>
        case "PROCESSED":<span class="cov0" title="0">
                return StatusProcessed</span>
        case "INVALID":<span class="cov0" title="0">
                return StatusInvalid</span>
        }
        <span class="cov0" title="0">return StatusUnknown</span>
}

func (s Status) String() string <span class="cov0" title="0">{
        switch s </span>{
        case StatusNew:<span class="cov0" title="0">
                return "NEW"</span>
        case StatusRegistered:<span class="cov0" title="0">
                return "REGISTERED"</span>
        case StatusProcessing:<span class="cov0" title="0">
                return "PROCESSING"</span>
        case StatusProcessed:<span class="cov0" title="0">
                return "PROCESSED"</span>
        case StatusInvalid:<span class="cov0" title="0">
                return "INVALID"</span>
        }
        <span class="cov0" title="0">return "unknown"</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package repository

import (
        "bytes"
        "context"
        "crypto/sha256"
        "encoding/hex"
        "errors"

        "github.com/jackc/pgx/v5"
        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/plasmatrip/gratify/internal/apperr"
        "github.com/plasmatrip/gratify/internal/logger"
        "github.com/plasmatrip/gratify/internal/models"
        "github.com/plasmatrip/gratify/internal/repository/schema"
)

type Repository struct {
        db *pgxpool.Pool
        l  logger.Logger
}

func NewRepository(ctx context.Context, dsn string, l logger.Logger) (*Repository, error) <span class="cov0" title="0">{
        // открываем БД
        db, err := pgxpool.New(ctx, dsn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">r := &amp;Repository{
                db: db,
                l:  l,
        }

        // // создаем таблицу, при ошибке прокидываем ее наверх
        // err = r.createTables(ctx)
        // if err != nil {
        //         return nil, err
        // }

        return r, nil</span>
}

func (r Repository) createTables(ctx context.Context) error <span class="cov0" title="0">{
        _, err := r.db.Exec(ctx, schema.DBSchema)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r Repository) Ping(ctx context.Context) error <span class="cov0" title="0">{
        return r.db.Ping(ctx)
}</span>

func (r Repository) Close() <span class="cov0" title="0">{
        r.db.Close()
}</span>

func (r Repository) CheckLogin(ctx context.Context, userLogin models.LoginRequest) error <span class="cov0" title="0">{
        var user models.LoginRequest

        row := r.db.QueryRow(ctx, schema.SelectUser, pgx.NamedArgs{"login": userLogin.Login})

        err := row.Scan(&amp;user.ID, &amp;user.Login, &amp;user.Password)
        if err != nil </span><span class="cov0" title="0">{
                if !errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">savedHash, err := hex.DecodeString(user.Password)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">h := sha256.New()
        h.Write([]byte([]byte(userLogin.Password)))
        hash := h.Sum(nil)

        if user.Login != userLogin.Login || !bytes.Equal(hash, savedHash) </span><span class="cov0" title="0">{
                return apperr.ErrBadLogin
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r Repository) RegisterUser(ctx context.Context, userLogin models.LoginRequest) (int32, error) <span class="cov0" title="0">{
        h := sha256.New()
        h.Write([]byte([]byte(userLogin.Password)))
        hash := hex.EncodeToString(h.Sum(nil))

        var id int32

        err := r.db.QueryRow(ctx, schema.InsertUser, pgx.NamedArgs{
                "login":    userLogin.Login,
                "password": hash,
        }).Scan(&amp;id)

        if err != nil </span><span class="cov0" title="0">{
                return -1, err
        }</span>

        <span class="cov0" title="0">return id, nil</span>
}

func (r Repository) AddOrder(ctx context.Context, order models.Order) error <span class="cov0" title="0">{
        rows, err := r.db.Query(ctx, schema.SelectOrderFromAnotherUser, pgx.NamedArgs{
                "id":      order.Number,
                "user_id": order.UserID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">rows.Close()

        if rows.CommandTag().RowsAffected() &gt; 0 </span><span class="cov0" title="0">{
                return apperr.ErrOrderAlreadyUploadedAnotherUser
        }</span>

        <span class="cov0" title="0">_, err = r.db.Exec(ctx, schema.InsertOrder, pgx.NamedArgs{
                "id":      order.Number,
                "user_id": order.UserID,
                "status":  order.Status,
                "date":    order.Date,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r Repository) GetOrders(ctx context.Context, userId int32) ([]models.Order, error) <span class="cov0" title="0">{
        orders := []models.Order{}

        rows, err := r.db.Query(ctx, schema.SelectOrders, pgx.NamedArgs{
                "user_id": userId,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                order := models.Order{}

                err := rows.Scan(
                        &amp;order.Number,
                        &amp;order.UserID,
                        &amp;order.Status,
                        &amp;order.Accrual,
                        &amp;order.Sum,
                        &amp;order.Date,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">orders = append(orders, order)</span>
        }

        <span class="cov0" title="0">return orders, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package router

import (
        "github.com/go-chi/chi/v5"
        "github.com/plasmatrip/gratify/internal/api"
        "github.com/plasmatrip/gratify/internal/api/auth"
        "github.com/plasmatrip/gratify/internal/api/balance"
        "github.com/plasmatrip/gratify/internal/api/info"
        "github.com/plasmatrip/gratify/internal/api/orders"
)

func NewRouter(deps api.Dependencies) *chi.Mux <span class="cov0" title="0">{

        r := chi.NewRouter()

        auth := auth.NewAuthService(deps)
        balance := balance.NewBalanceService(deps)
        orders := orders.NewOrdersService(deps)
        info := info.NewInfoService(deps)

        r.Use(deps.Logger.WithLogging)

        r.Route("/api/user/register", func(r chi.Router) </span><span class="cov0" title="0">{
                r.Post("/", auth.Register)
        }</span>)

        <span class="cov0" title="0">r.Route("/api/user/login", func(r chi.Router) </span><span class="cov0" title="0">{
                r.Post("/", auth.Login)
        }</span>)

        <span class="cov0" title="0">r.Route("/api/user/orders", func(r chi.Router) </span><span class="cov0" title="0">{
                r.Use(auth.Validate)
                r.Post("/", orders.AddOrder)
                r.Get("/", orders.GetOrders)
        }</span>)

        <span class="cov0" title="0">r.Route("/api/user/balance", func(r chi.Router) </span><span class="cov0" title="0">{
                r.Use(auth.Validate)
                r.Get("/", balance.GetBalance)
        }</span>)

        <span class="cov0" title="0">r.Route("/api/user/withdraw", func(r chi.Router) </span><span class="cov0" title="0">{
                r.Use(auth.Validate)
                r.Post("/", balance.Withdraw)
        }</span>)

        <span class="cov0" title="0">r.Route("/api/user/withdrawals", func(r chi.Router) </span><span class="cov0" title="0">{
                r.Use(auth.Validate)
                r.Get("/", balance.Withdrawals)
        }</span>)

        <span class="cov0" title="0">r.Route("/api/info", func(r chi.Router) </span><span class="cov0" title="0">{
                r.Get("/", info.Ping)
        }</span>)

        <span class="cov0" title="0">return r</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
